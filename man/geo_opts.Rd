% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/geo_transform.R
\name{geo_opts}
\alias{geo_opts}
\alias{geo_opts_points}
\alias{geo_opts_regrid}
\alias{geo_opts_subgrid}
\alias{geo_opts_zoom}
\alias{geo_opts_xsection}
\alias{geo_opts_upscale}
\title{Options for different transformations}
\usage{
geo_opts_points(
  points,
  method = c("bilinear", "nearest", "bicubic"),
  mask = NULL,
  force = FALSE,
  weights = NULL,
  keep_weights = FALSE
)

geo_opts_regrid(
  new_grid,
  method = c("bilinear", "nearest", "bicubic"),
  mask = NULL,
  new_mask = NULL,
  weights = NULL,
  keep_weights = FALSE
)

geo_opts_subgrid(i1, i2, j1, j2)

geo_opts_zoom(centre_lon, centre_lat, length_x, length_y)

geo_opts_xsection(
  p1,
  p2,
  n = 100,
  method = c("bilinear", "nearest", "bicubic"),
  weights = NULL,
  keep_weights = FALSE
)

geo_opts_upscale(factor, method = "mean", downsample_location = "bottom_left")
}
\arguments{
\item{points}{A data frame of geographic points to which to interpolate the
gridded data. The data frame must include the columns "SID" for a unique id
for the point, "lon" for the longitude of the point in decimal degrees and
"lat" for the latitude of the point in decimal degrees. The data frame can
contain other columns, which will be retained in the output.}

\item{method}{The interpolation method. Can be "nearest" for nearest
neighbour, "bilinear", or "bicubic." The default is "bilinear". For
\code{geo_upscale}, can be any function that summarises a vector to a
single value and can found with \code{\link[base]{match.fun}}, the default
being "mean". A further option is "downsample", which is described in the
argument for \code{downsample_location}. For \code{geo_regrid}, may also be "upscale"
for regridding to a coarser grid. This will take the mean of all the
pixel centroids of \code{x} that fall within a grid sqaure of the new grid.}

\item{mask}{A mask to prevent grid points being used in the interpolation.
Should be on the same grid as \code{x} and grid points with values of 0 or FALSE
will be masked from the interpolation.}

\item{force}{For interpolations that include a mask, it is possible that a
point will be surrounded by 4 masked points. In this case the mask will be
ignored and all 4 points used in the interpolation (the default). Set
\code{force = TRUE} to force the mask to be applied and set the interpolated to
\code{NA}.}

\item{weights}{Pre-computed weights for the interpolation. Should be the
output from the appropriate \link{geo_weights} function.}

\item{keep_weights}{Whether to keep weights in the output. If set to TRUE,
the return object will have a "weights" attribute.}

\item{new_grid}{A \code{geofield} or \code{geodomain} on the grid that \code{x} should be
regridded to. \link{define_domain} can be used to define a new \code{geodomain}.}

\item{new_mask}{A \code{geofield} on the same grid as \code{new_grid} with grid points
that should not be interpolated to set to 0 or FALSE.}

\item{i1}{The x index of the western side of the sub domain.}

\item{i2}{The x index of the eastern side of the sub domain.}

\item{j1}{The y index of the southern side of the sub domain.}

\item{j2}{The y index of the northern side of the sub domain.}

\item{centre_lon}{The longitude in decimal degrees of the centre of the
zoomed grid.}

\item{centre_lat}{The latitude in decimal degrees of the centre of the
zoomed grid.}

\item{length_x}{The number of grid squares from west to east of the zoomed
grid. If an even number is used, it will be extended by 1 since the zoomed
grid should be centred on the grid square containing
\verb{(centre_lat, centre_lon)}.}

\item{length_y}{The number of grid squares from south to north of the zoomed
grid. If an even number is used, it will be extended by 1 since the zoomed
grid should be centred on the grid square containing
\verb{(centre_lat, centre_lon)}.}

\item{p1}{The geographic location in decimal degrees of the start of the
section. Should be a vector of length 2 with the first value being the
longitude and the second value the latitude.}

\item{p2}{The geographic location in decimal degrees of the end of the
section. Should be a vector of length 2 with the first value being the
longitude and the second value the latitude.}

\item{n}{The number of equally spaced points along the section. The default
is 100.}

\item{factor}{An integer by which to upscale the data. Can be of length 2 to
achieve different upscaling in the x and directions.}

\item{downsample_location}{When "downsample" is the chosen method, each
pixel in the upscaled field is sampled from a pixel from the original field
that is inside the upscaled pixel. The location of that pixel can be one of
"bottom_left", "bottom_centre", "bottom_right", "left_centre", "centre",
"right_centre", "top_right", "top_centre", "top_left" or "random".}
}
\description{
When using \link{geo_transform} the transformation options must be passed as
named list appropriate to the transformation. These functions are used to
generate such named lists.
}
